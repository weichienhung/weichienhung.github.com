<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: emberjs | Practice makes perfect]]></title>
  <link href="http://weichienhung.github.io/blog/categories/emberjs/atom.xml" rel="self"/>
  <link href="http://weichienhung.github.io/"/>
  <updated>2014-08-02T11:31:33+08:00</updated>
  <id>http://weichienhung.github.io/</id>
  <author>
    <name><![CDATA[Weichien Hung]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Invoke Route from Controller in Emberjs]]></title>
    <link href="http://weichienhung.github.io/blog/2014/05/15/invoke-route-from-controller-in-emberjs/"/>
    <updated>2014-05-15T20:47:00+08:00</updated>
    <id>http://weichienhung.github.io/blog/2014/05/15/invoke-route-from-controller-in-emberjs</id>
    <content type="html"><![CDATA[<p>Emberjs official document doesn't describe how to invoke route method/event from controller. Why we need this?<br/>
Some methods(like <code>render</code>,<code>controllerFor</code>) only exist in Route scope.
``` javascript PostRoute
App.PostRoute = Ember.Route.extend({
  events: {</p>

<pre><code>showWarn: {
  this.render('warn', { "outlet": "msgView", "into": "post" })
}
</code></pre>

<p>  }
});
<code>
Use `this.get('target').send` to trigger Route event.
</code> javascript PostController
App.PostController = Ember.Controller.extend({
  actions: {</p>

<pre><code>showMessage: {
  //some process here
  if (need_render) {
    this.get('target').send('showWarn');
  }
}
</code></pre>

<p>  }
});
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dependency Injection in Emberjs]]></title>
    <link href="http://weichienhung.github.io/blog/2014/05/04/dependency-injection-in-emberjs/"/>
    <updated>2014-05-04T09:47:00+08:00</updated>
    <id>http://weichienhung.github.io/blog/2014/05/04/dependency-injection-in-emberjs</id>
    <content type="html"><![CDATA[<p>I read some articles about Emberjs Dependency Injection(DI) and try to upgrade my old project <a href="https://github.com/weichienhung/food-ntpc">food_ntpc</a>
to use DI. The pros of DI is to reduce gobal object and make code clean, testing easily.
There are few changes.</p>

<h3>before</h3>

<p>I create a <code>CategoryManager</code> and put in <code>FoodNtpc</code> App.
``` coffeescript category.js.coffee
class CategoryManager
  categorys: -></p>

<pre><code>return categorys
</code></pre>

<p>  ...</p>

<p>FoodNtpc.CategoryManager = new CategoryManager
<code>
It's very easy to access through `FoodNtpc.CategoryManager` everywhere. BUT it makes testing hardly and more coupling.
</code> coffeescript index_route.js.coffee
FoodNtpc.IndexRoute = Ember.Route.extend
  model: -></p>

<pre><code>return FoodNtpc.CategoryManager.categorys()
</code></pre>

<p>```</p>

<h3>after</h3>

<p>Only the <em>Ember.Object</em> class can be registered. I change <code>class CategoryManager</code> to <code>CategoryManager = Ember.Object.extend</code>.
Then create an <code>initializer</code> to register the <code>CategoryManager</code> in <code>foodntpc:categoryManager</code> naming. Set singleton to true because i want only one CategoryManager in system.
``` coffeescript category.js.coffee</p>

<h1>class CategoryManager</h1>

<p>CategoryManager = Ember.Object.extend
  categorys: -></p>

<pre><code>return categorys
</code></pre>

<p>  ...</p>

<h1>FoodNtpc.CategoryManager = new CategoryManager</h1>

<p>Ember.Application.initializer
  name: 'categoryManager'
  initialize: (container, application) -></p>

<pre><code>console.log 'register categoryManager'
container.register('foodntpc:categoryManager', CategoryManager, {singleton: true})
</code></pre>

<p><code>
Next, create another initializer to inject those dependency. We can use `after` or `before` to adjust initializer sequence.  
In `application.js` line 6 means `foodntpc:categoryManager` is injected to IndexRoute and use `CategoryManager` reference.
In line 7 means inject into all controller.
</code> javascript application.js
Ember.Application.initializer({
  name: 'injectModelManager',
  after: 'categoryManager',</p>

<p>  initialize: function(container, application) {</p>

<pre><code>application.inject('route:index', 'CategoryManager', 'foodntpc:categoryManager');
application.inject('controller', 'CategoryManager', 'foodntpc:categoryManager');
</code></pre>

<p>  }
});
<code>
In IndexRoute, we use `this.CategoryManager` to access it.
</code> coffeescript index_route.js.coffee
FoodNtpc.IndexRoute = Ember.Route.extend
  model: -></p>

<pre><code>return @CategoryManager.categorys()
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unit testing in Emberjs]]></title>
    <link href="http://weichienhung.github.io/blog/2014/03/08/unit-testing-in-emberjs/"/>
    <updated>2014-03-08T12:52:00+08:00</updated>
    <id>http://weichienhung.github.io/blog/2014/03/08/unit-testing-in-emberjs</id>
    <content type="html"><![CDATA[<p>I apply the <a href="https://qunitjs.com/">QUnit</a> to my Emberjs project to do unit/integration testing.
In unit testing we usually have to mock object/methods to test every condition.
I choose <a href="http://sinonjs.org/">SinonJS</a> as my mock library. It's really easy to use.</p>

<p>Let's see how to unit testing my components.</p>

<h3>Testing html</h3>

<p>Create a html that includes qunit,sinon,emberjs and your source codes. Remeber to use debug Emberjs(<code>ember-1.x.x.js</code>) not production(<code>ember-1.x.x.min.js</code>)<br/>
Make sure you invoke <code>setupForTesting</code> and <code>injectTestHelpers</code> after Application created.
``` html test.html
<head>
  <!-- vendor libs -->
  <script src="js/vendor/jquery-1.9.1.min.js"></script>
  <script src="js/vendor/handlebars-1.0.0.js"></script>
  <script src="lib/ember-1.0.1.js"></script></p>

<p>  <!-- testing libs -->
  <script src="lib/qunit-1.14.0.js"></script>
  <link rel="stylesheet" href="lib/qunit-1.14.0.css"></p>

<p>  <!-- mock libs -->
  <script src="lib/sinon-1.8.2.js"></script></p>

<p>  <!-- source codes -->
  <script src="js/components/lobby.component.js"></script>
</head>
<body>
  <div id="application"></div></p>

<p>  <script></p>

<pre><code>var MyApp = Ember.Application.create({
  rootElement: '#application',
});
MyApp.setupForTesting();
MyApp.injectTestHelpers();
</code></pre>

<p>  </script></p>

<p>  <!-- spec codes -->
  <script src="spec/lobby.spec.js"></script>
</body>
```</p>

<h3>Route</h3>

<p>I have a lobby route.
``` javascript LobbyRoute
MyApp.LobbyRoute = Ember.Route.extend({
  renderTemplate : function(){</p>

<pre><code>this.render("lobby", { controller: "lobby" } );
</code></pre>

<p>  }
});
<code>``
In QUnit we could use</code>module()<code>to group test cases.</code>test()<code>after</code>module()<code>will be grouped.
Then we could add</code>setup<code>and</code>teardown` methods. They will be invoked in each test case.</p>

<p>``` javascript lobby.spec.js
module("LobbyRoute", {
  setup: function() {</p>

<pre><code>MyApp.reset();
</code></pre>

<p>  },
  teardown: function() {</p>

<pre><code>//do something here.
</code></pre>

<p>  }
});</p>

<p>test("should render lobby template", function() {
  Ember.run(this,function(){</p>

<pre><code>route = MyApp.__container__.lookup('route:lobby');

sinon.spy(route, "render");
route.renderTemplate();
ok(route.render.calledOnce, "render should be calledOnce");  
</code></pre>

<p>  });
});
<code>``
Above example uses Ember's</code><strong>container</strong>.lookup<code>to find specific component and testing it.  
But how we make sure the specified method is called?
Use</code>sinon.spy` to spy a object/method and check it.</p>

<!-- more -->


<h3>Controller</h3>

<p>I have a <code>backward</code> function and it will invoke <code>exitApp</code> when <code>isWebview()</code> is true.
``` javascript LobbyController
MyApp.LobbyController = application.AccessibleObjectController.extend({
  backward : function(){</p>

<pre><code>if( ViewManager.isWebview() ){
  LifeManager.exitApp();
}         
</code></pre>

<p>  }
});
<code>
In below example, we `stub` the ViewManager's `isWebview` method.
I want it returns true during testing. Here is a little difference from previous example.
In the last two lines. I have to invoke `restore` in each stub/spy method.
Why? The same method can't be spy/stub twice.  We have to `restore` it to prevent other test cases be influenced.
Why previous example doesn't have `restore` in route? Because lobby route is in Ember container and it will be re-created in `MyApp.reset()`
</code> javascript lobby.spec.js
test("backward should invoke exitApp in webview", function() {
  Ember.run(this, function() {</p>

<pre><code>controller = MyApp.__container__.lookup('controller:lobby');
sinon.stub(ViewManager, "isWebview").returns(true);
sinon.spy(LifeManager, "exitApp");
controller.backward();

//assert
equal(LifeManager.exitApp.callCount, 1, "LifeManager.exitApp should be called");

ViewManager.isWebview.restore();
LifeManager.exitApp.restore();
</code></pre>

<p>  });
});
```</p>

<h3>View</h3>

<p>Have a lobby view and template as below.
``` javascript LobbyView
MyApp.LobbyView = Ember.View.extend({
  templateName : 'tmp_lobby',
  classNames: ['lobby-layout'],
});
Ember.TEMPLATES.tmp_lobby = Ember.Handlebars.compile(
  ['<div class="lobby-header">',</p>

<pre><code> '&lt;div class="lobby-logo"&gt;&lt;/div&gt;',
</code></pre>

<p>   '</div>',
   '<div class="lobby-content"></div>'
  ].join(""));
<code>
In `setup` we have to append view to document.
Then we could use css selector to find expected element.
Remeber to remove it from document in `teardown`.
</code> javascript lobby.spec.js
module("LobbyView", {
  setup: function() {</p>

<pre><code>Gamenow.reset();
Ember.run(this, function () {
  this.view = MyApp.__container__.lookup('view:lobby');
  this.view.append(); // Hook up to our document.
});
</code></pre>

<p>  },
  teardown: function () {</p>

<pre><code>Ember.run(this, function () {
  this.view.remove(); // Unhook from our document.
});
</code></pre>

<p>  }
});</p>

<p>test("header should has logo", function () {
  equal(this.view.$(".lobby-header .lobby-logo").length, 1, ".lobby-logo should exist");
});</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[emberjs-data trying]]></title>
    <link href="http://weichienhung.github.io/blog/2014/01/11/emberjs-data-trying/"/>
    <updated>2014-01-11T11:05:00+08:00</updated>
    <id>http://weichienhung.github.io/blog/2014/01/11/emberjs-data-trying</id>
    <content type="html"><![CDATA[<p>In my old emberjs project(<a href="https://github.com/weichienhung/money">money</a>,<a href="https://github.com/weichienhung/food-ntpc">food-ntpc</a>)
i didn't use <a href="https://github.com/emberjs/data">ember-data</a> to handle data processing with backend server.
The ember-data is closed to 1.0.0(now is 1.0.0.beta4) so i give it a try.
The official document is quite less and some posts in StackOverflow are out of date.
Checkout their source code is the quickest way to understand how they work and do customized.
I write down tips here for my reference in the future.</p>

<p>Define your store to use ember-data
``` coffeescript
MyAdapter = DS.RESTAdapter.extend</p>

<p>MyApp.Store = DS.Store.extend
  revision: 11
  adapter: MyAdapter
```</p>

<p>Assume your have a <code>record</code> object and json format is
``` json
{
  "record": {</p>

<pre><code>"id":"1",
"amount":150,
"category_id":1,
"description":"dinner"
</code></pre>

<p>  }
}
<code>
Define your model object.
</code> coffeescript
MyApp.Record = DS.Model.extend
  category_id: DS.attr 'number'
  amount: DS.attr 'number'
  description: DS.attr 'string'
```</p>

<!-- more -->


<p>Get all <code>MyApp.Record</code> from backend server.
``` coffeescript
MyApp.ApplicationRoute = Ember.Route.extend
  model: (params)-></p>

<pre><code>model = @store.find 'record'
return model
</code></pre>

<p><code>
_If you want to use store without in route,controller_
</code>
MyApp.<strong>container</strong>.lookup('store:main').find 'record'
<code>
The backend should provide the REST api path `http://127.0.0.1/records`.  
Server response json should be like
</code> json
{
  "records": [{</p>

<pre><code>"id":"1",
"amount":150,
"category_id":1,
"description":"dinner"
</code></pre>

<p>  },
  {</p>

<pre><code>"id":"2",
"amount":250,
"category_id":1,
"description":"lunch"
</code></pre>

<p>  }]
}
<code>
The default root of json become `records` not `record` and content should be a Array.  
In case you want to pass parameter into URL like `http://127.0.0.1/records?year=2014`.
</code> coffeescript
MyApp.ApplicationRoute = Ember.Route.extend
  model: (params)-></p>

<pre><code>model = @store.find 'record', { year: 2014 }
return model
</code></pre>

<p>```</p>

<p>Get single record.
``` coffeescript
MyApp.RecordRoute = Ember.Route.extend
  model: (params)-></p>

<pre><code># assume params.id is 1
model = @store.find 'record', params.id
return model
</code></pre>

<p><code>``
The backend should provide the REST api path</code>http://127.0.0.1/record/1`.</p>

<h2>Customerized</h2>

<h3>change default request url</h3>

<p>Your backend server may provide REST api like <code>http://127.0.0.1/api/records</code>.
You could add namesapce to your rest adapter.
<code>
MyAdapter = DS.RESTAdapter.extend
  namespace: 'api'
</code></p>

<h3>change single model request url</h3>

<p>Your backend server doesn't provide REST api <code>http://127.0.0.1/api/records</code> but <code>http://127.0.0.1/api/usages</code>.
The responsed json format doesn't change.
```
records_pattern = ///
  api/records
///</p>

<p>MyAdapter = DS.RESTAdapter.extend
  namespace: 'api'
  buildURL: (type,id)-></p>

<pre><code>url = @._super(type, id)
if url.match records_pattern
  url = url.replace 'records', 'usages'
return url
</code></pre>

<p>```</p>

<h3>change root of responsed json</h3>

<p>Your backend server change the default json format from
``` json
{
  "records": [{</p>

<pre><code>"id":"1",
"amount":150,
"category_id":1,
"description":"dinner"
</code></pre>

<p>  },
  {</p>

<pre><code>"id":"2",
"amount":250,
"category_id":1,
"description":"lunch"
</code></pre>

<p>  }]
}
<code>
to
</code>
{
  "usages": [{</p>

<pre><code>"id":"1",
"amount":150,
"category_id":1,
"description":"dinner"
</code></pre>

<p>  },
  {</p>

<pre><code>"id":"2",
"amount":250,
"category_id":1,
"description":"lunch"
</code></pre>

<p>  }]
}
<code>
Simple extend the original serializer and overwrite methods
</code> coffeescript
MyApp.RecordSerializer = DS.RESTSerializer.extend
  typeForRoot: (root) -></p>

<pre><code>return "usage"
</code></pre>

<p>```
Refer to <a href="https://github.com/emberjs/data/blob/master/packages/ember-data/lib/serializers/rest_serializer.js">rest_serializer.js</a> to know more customerized.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Async in Emberjs]]></title>
    <link href="http://weichienhung.github.io/blog/2013/09/22/async-in-emberjs/"/>
    <updated>2013-09-22T17:40:00+08:00</updated>
    <id>http://weichienhung.github.io/blog/2013/09/22/async-in-emberjs</id>
    <content type="html"><![CDATA[<h2>Async Routing</h2>

<p>Reference to <a href="http://emberjs.com/guides/routing/asynchronous-routing/">ember guide</a>.<br/>
If you want to make sure model is ready before entering the target route. You could use async routing. How?<br/>
Make your model as Promise object in route's model function.
For example: In year route i return a model that comes from <code>ModelMgr.listMonth(params.year_id)</code>.
Because model is Promise object, i add a <code>then</code> method to set id attribute to model(resolve will be model here)
``` coffeescript YearRoute
model: (params) ->
  model = ModelMgr.listMonth(params.year_id)</p>

<pre><code>model.then (resolve, reject)-&gt;
  resolve.set 'id', params.year_id
</code></pre>

<p>  return model
<code>
In `ModelMgr.listMonth` method, use `Ember.RSVP.Promise` to wrap your function. Because i don't return anything in the last line of function.
CoffeeScript will return the promise object automatically. `months` will be the real model object.
</code> coffeescript ModelMgr
listMonth: (year) ->
  months = Ember.ArrayProxy.create({content:[]})
  new Ember.RSVP.Promise (resolve) -></p>

<pre><code>$.ajax '/api/list',
type: 'GET'
dataType: 'json'
data: 'y='+year
success: (data, textStatus, jqXHR) -&gt;
  for raw in data
    months.addObject raw
  months.set 'isReady', true
  resolve(months)
</code></pre>

<p>```</p>

<h2>Wait multiple function call ready</h2>

<p>Sometimes you will use 3rd party library and it requires element existed in the DOM tree.
For example: I use highchartJS to draw diagram.<br/>
In the route it queries two models to finish the whole scenarios.
<code>model</code> is the result from <code>ModelMgr.listMonth</code> and <code>modelForTrend</code> is the result from <code>ModelMgr.queryTrend</code>.
The models all have attributes called <code>isReady</code> with false default. After <code>ModelMgr</code> get the data, it will set to true.
``` coffeescript SummaryRoute
  model: (params)-></p>

<pre><code>model = ModelMgr.listMonth(params.year_id)
model.year = params.year_id #For queryTrend needs year as parameter
return model
</code></pre>

<p>  setupController: (controller, model)-></p>

<pre><code>modelForTrend = ModelMgr.queryTrend(model.year)
controller.set 'model', model
controller.set 'modelForTrend', modelForTrend
</code></pre>

<p><code>
We have two attribute bindings to model's attributes in controller.
</code> coffeescript SummaryController
SummaryController = Ember.ObjectController.extend
  dataReadyBinding: 'model.isReady'
  trendDataReadyBinding: 'modelForTrend.isReady'
```</p>

<p>Create a method to observe all attributes we care about. View shouldn't connect to Model directly.
So i make <code>drawLineChart</code> method to observe controller's attribute.
``` coffeescript SummaryView
SummaryView = Ember.View.extend
  elementReady: false
  drawLineChart: ( -></p>

<pre><code>if @get('controller.dataReady') and @get('controller.trendDataReady') and @get('elementReady')
  content = @get 'controller.model.content' # content is ready
  contentForTrend = @get 'controller.modelForTrend.content' # contentForTrend is ready
  $('#myTrend').highcharts( ... ) # element is ready.
  # do something here...
</code></pre>

<p>  ).observes('controller.dataReady', 'elementReady', 'controller.trendDataReady')
  didInsertElement: -></p>

<pre><code>@set 'elementReady', true
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
