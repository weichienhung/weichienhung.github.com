<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: emberjs | Weichien's studying note]]></title>
  <link href="http://weichienhung.github.io/blog/categories/emberjs/atom.xml" rel="self"/>
  <link href="http://weichienhung.github.io/"/>
  <updated>2014-01-25T14:24:49+08:00</updated>
  <id>http://weichienhung.github.io/</id>
  <author>
    <name><![CDATA[Weichien Hung]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[emberjs-data trying]]></title>
    <link href="http://weichienhung.github.io/blog/2014/01/11/emberjs-data-trying/"/>
    <updated>2014-01-11T11:05:00+08:00</updated>
    <id>http://weichienhung.github.io/blog/2014/01/11/emberjs-data-trying</id>
    <content type="html"><![CDATA[<p>In my old emberjs project(<a href="https://github.com/weichienhung/money">money</a>,<a href="https://github.com/weichienhung/food-ntpc">food-ntpc</a>)
i didn't use <a href="https://github.com/emberjs/data">ember-data</a> to handle data processing with backend server.
The ember-data is closed to 1.0.0(now is 1.0.0.beta4) so i give it a try.
The official document is quite less and some posts in StackOverflow are out of date.
Checkout their source code is the quickest way to understand how they work and do customized.
I write down tips here for my reference in the future.</p>

<p>Define your store to use ember-data
``` coffeescript
MyAdapter = DS.RESTAdapter.extend</p>

<p>MyApp.Store = DS.Store.extend
  revision: 11
  adapter: MyAdapter
```</p>

<p>Assume your have a <code>record</code> object and json format is
``` json
{
  "record": {</p>

<pre><code>"id":"1",
"amount":150,
"category_id":1,
"description":"dinner"
</code></pre>

<p>  }
}
<code>
Define your model object.
</code> coffeescript
MyApp.Record = DS.Model.extend
  category_id: DS.attr 'number'
  amount: DS.attr 'number'
  description: DS.attr 'string'
```</p>

<!-- more -->


<p>Get all <code>MyApp.Record</code> from backend server.
``` coffeescript
MyApp.ApplicationRoute = Ember.Route.extend
  model: (params)-></p>

<pre><code>model = @store.find 'record'
return model
</code></pre>

<p><code>
_If you want to use store without in route,controller_
</code>
MyApp.<strong>container</strong>.lookup('store:main').find 'record'
<code>
The backend should provide the REST api path `http://127.0.0.1/records`.  
Server response json should be like
</code> json
{
  "records": [{</p>

<pre><code>"id":"1",
"amount":150,
"category_id":1,
"description":"dinner"
</code></pre>

<p>  },
  {</p>

<pre><code>"id":"2",
"amount":250,
"category_id":1,
"description":"lunch"
</code></pre>

<p>  }]
}
<code>
The default root of json become `records` not `record` and content should be a Array.  
In case you want to pass parameter into URL like `http://127.0.0.1/records?year=2014`.
</code> coffeescript
MyApp.ApplicationRoute = Ember.Route.extend
  model: (params)-></p>

<pre><code>model = @store.find 'record', { year: 2014 }
return model
</code></pre>

<p>```</p>

<p>Get single record.
``` coffeescript
MyApp.RecordRoute = Ember.Route.extend
  model: (params)-></p>

<pre><code># assume params.id is 1
model = @store.find 'record', params.id
return model
</code></pre>

<p><code>``
The backend should provide the REST api path</code>http://127.0.0.1/record/1`.</p>

<h2>Customerized</h2>

<h3>change default request url</h3>

<p>Your backend server may provide REST api like <code>http://127.0.0.1/api/records</code>.
You could add namesapce to your rest adapter.
<code>
MyAdapter = DS.RESTAdapter.extend
  namespace: 'api'
</code></p>

<h3>change single model request url</h3>

<p>Your backend server doesn't provide REST api <code>http://127.0.0.1/api/records</code> but <code>http://127.0.0.1/api/usages</code>.
The responsed json format doesn't change.
```
records_pattern = ///
  api/records
///</p>

<p>MyAdapter = DS.RESTAdapter.extend
  namespace: 'api'
  buildURL: (type,id)-></p>

<pre><code>url = @._super(type, id)
if url.match records_pattern
  url = url.replace 'records', 'usages'
return url
</code></pre>

<p>```</p>

<h3>change root of responsed json</h3>

<p>Your backend server change the default json format from
``` json
{
  "records": [{</p>

<pre><code>"id":"1",
"amount":150,
"category_id":1,
"description":"dinner"
</code></pre>

<p>  },
  {</p>

<pre><code>"id":"2",
"amount":250,
"category_id":1,
"description":"lunch"
</code></pre>

<p>  }]
}
<code>
to
</code>
{
  "usages": [{</p>

<pre><code>"id":"1",
"amount":150,
"category_id":1,
"description":"dinner"
</code></pre>

<p>  },
  {</p>

<pre><code>"id":"2",
"amount":250,
"category_id":1,
"description":"lunch"
</code></pre>

<p>  }]
}
<code>
Simple extend the original serializer and overwrite methods
</code> coffeescript
MyApp.RecordSerializer = DS.RESTSerializer.extend
  typeForRoot: (root) -></p>

<pre><code>return "usage"
</code></pre>

<p>```
Refer to <a href="https://github.com/emberjs/data/blob/master/packages/ember-data/lib/serializers/rest_serializer.js">rest_serializer.js</a> to know more customerized.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Async in Emberjs]]></title>
    <link href="http://weichienhung.github.io/blog/2013/09/22/async-in-emberjs/"/>
    <updated>2013-09-22T17:40:00+08:00</updated>
    <id>http://weichienhung.github.io/blog/2013/09/22/async-in-emberjs</id>
    <content type="html"><![CDATA[<h2>Async Routing</h2>

<p>Reference to <a href="http://emberjs.com/guides/routing/asynchronous-routing/">ember guide</a>.<br/>
If you want to make sure model is ready before entering the target route. You could use async routing. How?<br/>
Make your model as Promise object in route's model function.
For example: In year route i return a model that comes from <code>ModelMgr.listMonth(params.year_id)</code>.
Because model is Promise object, i add a <code>then</code> method to set id attribute to model(resolve will be model here)
``` coffeescript YearRoute
model: (params) ->
  model = ModelMgr.listMonth(params.year_id)</p>

<pre><code>model.then (resolve, reject)-&gt;
  resolve.set 'id', params.year_id
</code></pre>

<p>  return model
<code>
In `ModelMgr.listMonth` method, use `Ember.RSVP.Promise` to wrap your function. Because i don't return anything in the last line of function.
CoffeeScript will return the promise object automatically. `months` will be the real model object.
</code> coffeescript ModelMgr
listMonth: (year) ->
  months = Ember.ArrayProxy.create({content:[]})
  new Ember.RSVP.Promise (resolve) -></p>

<pre><code>$.ajax '/api/list',
type: 'GET'
dataType: 'json'
data: 'y='+year
success: (data, textStatus, jqXHR) -&gt;
  for raw in data
    months.addObject raw
  months.set 'isReady', true
  resolve(months)
</code></pre>

<p>```</p>

<h2>Wait multiple function call ready</h2>

<p>Sometimes you will use 3rd party library and it requires element existed in the DOM tree.
For example: I use highchartJS to draw diagram.<br/>
In the route it queries two models to finish the whole scenarios.
<code>model</code> is the result from <code>ModelMgr.listMonth</code> and <code>modelForTrend</code> is the result from <code>ModelMgr.queryTrend</code>.
The models all have attributes called <code>isReady</code> with false default. After <code>ModelMgr</code> get the data, it will set to true.
``` coffeescript SummaryRoute
  model: (params)-></p>

<pre><code>model = ModelMgr.listMonth(params.year_id)
model.year = params.year_id #For queryTrend needs year as parameter
return model
</code></pre>

<p>  setupController: (controller, model)-></p>

<pre><code>modelForTrend = ModelMgr.queryTrend(model.year)
controller.set 'model', model
controller.set 'modelForTrend', modelForTrend
</code></pre>

<p><code>
We have two attribute bindings to model's attributes in controller.
</code> coffeescript SummaryController
SummaryController = Ember.ObjectController.extend
  dataReadyBinding: 'model.isReady'
  trendDataReadyBinding: 'modelForTrend.isReady'
```</p>

<p>Create a method to observe all attributes we care about. View shouldn't connect to Model directly.
So i make <code>drawLineChart</code> method to observe controller's attribute.
``` coffeescript SummaryView
SummaryView = Ember.View.extend
  elementReady: false
  drawLineChart: ( -></p>

<pre><code>if @get('controller.dataReady') and @get('controller.trendDataReady') and @get('elementReady')
  content = @get 'controller.model.content' # content is ready
  contentForTrend = @get 'controller.modelForTrend.content' # contentForTrend is ready
  $('#myTrend').highcharts( ... ) # element is ready.
  # do something here...
</code></pre>

<p>  ).observes('controller.dataReady', 'elementReady', 'controller.trendDataReady')
  didInsertElement: -></p>

<pre><code>@set 'elementReady', true
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use HighchartJS to visual data]]></title>
    <link href="http://weichienhung.github.io/blog/2013/09/22/use-highchartjs-to-visual/"/>
    <updated>2013-09-22T17:16:00+08:00</updated>
    <id>http://weichienhung.github.io/blog/2013/09/22/use-highchartjs-to-visual</id>
    <content type="html"><![CDATA[<p>I just push a new project to <a href="https://github.com/weichienhung/money">github</a> and <a href="http://weichien-money.herokuapp.com/">heroku</a>.
This project is derived from my iOS App <a href="https://itunes.apple.com/tw/app/monny/id590327036?mt=8">Monny</a>.
The App I used it to record my daily expense. The free version doesn't have visual graph to show summary data.
So i use EmberJS,HighchartJS and Rails to build this simple web app. I always learned new knowledge during coding.</p>

<p>I take few snaphots of this probject.</p>

<!-- more -->


<h3>List every record</h3>

<p><img src="/images/posts/0922-list.png" width="500" height="500" title="list-image" alt="list"></p>

<h3>Category summary</h3>

<p><img src="/images/posts/0922-summary.png" width="500" height="500" title="summary-image" alt="summary"></p>

<h3>Year trend</h3>

<p><img src="/images/posts/0922-trend.png" width="500" height="500" title="trend-image" alt="trend"></p>

<p>I won't describe studying notes here but write them in other posts.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First ember_rails project]]></title>
    <link href="http://weichienhung.github.io/blog/2013/09/03/first-ember-rails-project/"/>
    <updated>2013-09-03T23:57:00+08:00</updated>
    <id>http://weichienhung.github.io/blog/2013/09/03/first-ember-rails-project</id>
    <content type="html"><![CDATA[<p>Last time i said i want to make an ember-rails project(<a href="http://127.0.0.1:4000/blog/2013/08/25/rails-and-ember-study/">post</a>).
Today I push my first Ember-Rails(food-ntpc) project to <a href="https://github.com/weichienhung/food-ntpc">github</a> and <a href="http://food-ntpc.herokuapp.com/">heroku</a>.
It takes me more time to finish it because i am not familiar with coffee script. I also create a new <a href="http://weichienhung.github.io/blog/2013/09/01/coffee-script-memo/">post</a> for coffee script memo.
During practicing i use Emberjs 1.0.0.rc7. But Emberjs 1.0.0 was released few days ago and i upgrade it to 1.0.0.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Multiple models in a view]]></title>
    <link href="http://weichienhung.github.io/blog/2013/09/01/multiple-model-in-a-view/"/>
    <updated>2013-09-01T20:29:00+08:00</updated>
    <id>http://weichienhung.github.io/blog/2013/09/01/multiple-model-in-a-view</id>
    <content type="html"><![CDATA[<p>How to use multiple models in a view?
Retrieve another data and set to controller in Route's setupController method.
``` coffeescript
model: ->
  return Place.places()</p>

<p>setupController: (controller, model) ->
  #model is the result of Place.places()
  controller.set 'content', model</p>

<p>  #another data
  categorys = Category.categorys()
  controller.set 'categorys', categorys
```
I create CategoryView and bind data to it in template</p>

<pre>
&#123;{#each category in categorys}}
  &#123;{#view CategoryView contentBinding="category"}}
    &#123;{category.name}}
  &#123;{/view}}
&#123;{/each}}

&#123;{#each place in content}}
  &#123;{place.name}}
&#123;{/each}}
</pre>


<p>CategoryView code:
I use classNameBinding to auto update class when status is changed.
```
CategoryView = Ember.View.extend
  classNameBindings: ['getClass']
  status: true</p>

<p>  getClass: ( -></p>

<pre><code>if this.get('status')
  return "btn-info"
else
  return "btn-default"
</code></pre>

<p>  ).property('status')
```</p>
]]></content>
  </entry>
  
</feed>
