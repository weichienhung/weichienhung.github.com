<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Practice makes perfect]]></title>
  <link href="http://weichienhung.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://weichienhung.github.io/"/>
  <updated>2014-10-13T22:58:40+08:00</updated>
  <id>http://weichienhung.github.io/</id>
  <author>
    <name><![CDATA[Weichien Hung]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[jsdc_2014]]></title>
    <link href="http://weichienhung.github.io/blog/2014/10/13/jsdc-2014/"/>
    <updated>2014-10-13T22:51:00+08:00</updated>
    <id>http://weichienhung.github.io/blog/2014/10/13/jsdc-2014</id>
    <content type="html"><![CDATA[<p>剛參加完JSDC 2014, 做筆紀</p>

<h3><a href="http://browserify.org/">Browserify</a></h3>

<p>將原本跑在nodejs的javascript code以及dependencies打包後產生可以跑在browser上面的code. 很酷的是主講者還自己做了minecraft的Taipei 101版本.<br/>
主講者<a href="https://github.com/maxogden">Github link</a></p>

<h3><a href="http://zeromq.org/">ZeroMQ</a></h3>

<p>有兩個主題都跟ZeroMQ有關. 第一天的Casear簡單地介紹了在使用ZeroMQ遇到的一些問題,像是Security, Auth. 並且自己寫了一個ZeroMQ-SOA的module <a href="https://github.com/Casear/zmq-soa">zmq-soa</a><br/>
第二天的主講者則是介紹了ZeroMQ訊息機制. PUSH/PULL, Pub/Sub. 以及在message queue滿了之後的MUTE機制. 該Block或Drop</p>

<h3>HTML Accessibility</h3>

<p>講者提到幾乎沒人注重的Accessibility並且用Mac safari裡的voice over功能演示去瀏覽有提供Accessibilty的網站時, 盲人也能夠透過語音導覽協助來使用網站. 作者web site <a href="https://yuehu.io/">閱乎</a></p>

<h3>Functional programming in javascript</h3>

<p>很硬. 聽不太懂. 有提到Haskell及Monad</p>

<h3><a href="http://reactive-extensions.github.io/RxJS/">RxJS</a></h3>

<p>主要是一個來解決非同步式問題的library. (Async is hard) 用裡面現成許多寫法的函數可以有效來處理非同步式問題.</p>

<h3><a href="https://github.com/google/leveldb">leveldb</a></h3>

<p>一種微型資料庫(micro database). 主要是由google開發. 方便在做一些小型project. 本身是key-value based所以也不會有什麼SQL support</p>

<h3><a href="https://github.com/google/leveldb">KOA</a></h3>

<p>一個架構在Express之上的nodejs web framework. 用ES6 generator的寫法來寫middleware並加進request flow裡面. 官網有example描述如何在不改動原本的程式碼之下log每一個request process time及增加response header</p>

<h3>Teaching Git and GitHub with Node.js</h3>

<p>主講者介紹她如何製作互動式教學教人使用Github. 用的工具是用<a href="http://nodeschool.io/">nodeschool</a>裡面製作課程的工具相同. 這是她的project <a href="https://github.com/jlord/git-it">Git-it</a></p>

<h3>大型互聯網公司前端團隊的那些事兒</h3>

<p>這個就跟技術沒有太多關係,主要是講管理一個團隊遇到的一些事情.</p>

<h3>Node.js, p2p and MAD SCIENCE</h3>

<p>主講者用javascript來實作p2p protocol並且還自己寫了幾種應用<br/>
1. <a href="https://github.com/mafintosh/torrent-stream">torrent-stream</a> p2p stream data<br/>
2. <a href="https://github.com/mafintosh/peerflix">peerflix</a> stream data to VLC<br/>
3. <a href="https://github.com/mafintosh/torrent-mount">torrent-mount</a> mount a virtual file using p2p.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[js/css build optimize flow]]></title>
    <link href="http://weichienhung.github.io/blog/2014/08/02/js-slash-css-build-optimize-flow/"/>
    <updated>2014-08-02T09:58:00+08:00</updated>
    <id>http://weichienhung.github.io/blog/2014/08/02/js-slash-css-build-optimize-flow</id>
    <content type="html"><![CDATA[<p>I changed the my work frontend module build optimize flow few day ago.
The original build flow is use <a href="https://code.google.com/p/wro4j/wiki/MavenPlugin">wro4j plugin</a> and my buildhelper. The cons is that there're many trivial steps when adding a new page.
I decide to update it with new way. I study the <a href="http://yeoman.io">YEOMAN</a> build flow and apply it in my module. The result is good.</p>

<p>YEOMAN uses nodejs and <a href="http://gruntjs.com">Grunt</a> to do optimize.
But the company module system is using Maven. The first step is to find a maven plugin to run grunt. I choose <a href="https://github.com/allegro/grunt-maven-plugin">grunt-maven-plugin</a> and it's easy to integrate.</p>

<!-- more -->


<p>See my snippet code from pom.xml. I copy all files from <code>src/main/webapp</code> to <code>${project.build.directory}/original</code> and run grunt in prepare package phase. I don't want to let grunt access <code>src/main/webapp</code> so the <code>${project.build.directory}/original</code> will be my grunt project source folder.
``` xml pom.xml
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-resources-plugin</artifactId>
  <version>2.6</version>
  <executions></p>

<pre><code>&lt;!-- copy webapp to target folder --&gt;         
&lt;execution&gt;
  &lt;id&gt;copy-webapp&lt;/id&gt;
  &lt;phase&gt;process-resources&lt;/phase&gt;
  &lt;goals&gt;
    &lt;goal&gt;copy-resources&lt;/goal&gt;
  &lt;/goals&gt;
  &lt;configuration&gt;
    &lt;outputDirectory&gt;${project.build.directory}/original&lt;/outputDirectory&gt;
    &lt;resources&gt;          
      &lt;resource&gt;
        &lt;directory&gt;src/main/webapp/&lt;/directory&gt;
      &lt;/resource&gt;
    &lt;/resources&gt;
  &lt;/configuration&gt;  
&lt;/execution&gt;
</code></pre>

<p>  </executions>
</plugin></p>

<p><plugin>
  <groupId>pl.allegro</groupId>
  <artifactId>grunt-maven-plugin</artifactId>
  <version>1.2.1</version>
  <configuration></p>

<pre><code>&lt;showColors&gt;true&lt;/showColors&gt;
</code></pre>

<p>  </configuration>
  <executions></p>

<pre><code>&lt;execution&gt;
  &lt;id&gt;grunt-build&lt;/id&gt;
  &lt;phase&gt;prepare-package&lt;/phase&gt;
  &lt;goals&gt;
    &lt;goal&gt;npm&lt;/goal&gt;
    &lt;goal&gt;grunt&lt;/goal&gt;
  &lt;/goals&gt;
&lt;/execution&gt;
</code></pre>

<p>  </executions>
</plugin>
```</p>

<p>Here i will skip the installation of yeoman. Let's see how yeoman build flow work.
I set the <code>gamenow.app</code> to <code>target/original</code> that is the folder copy from <code>src/main/webapp</code>. <code>gamenow.dist</code> will be <code>target/storefront</code> and this folder will be packaged to WAR file in maven build.
``` javascript Gruntfile.js
module.exports = function (grunt) {
  // Load grunt tasks automatically
  require('load-grunt-tasks')(grunt);</p>

<p>  // Time how long tasks take. Can help when optimizing build times
  require('time-grunt')(grunt);</p>

<p>  grunt.initConfig({</p>

<pre><code>gamenow: {
  // Configurable paths
  app: 'target/original',
  dist: 'target/storefront'
},

....
</code></pre>

<p>  });
<code>
YEOMAN uses usemin grunt plugin to create concat,minify,rewrite. In `useminPrepare` setting i set the html sources in `&lt;%= gamenow.app %&gt;/*.html`. It means usemin plugin will search all .html files and find the build block description to create configuration automatically. You will see how to set build block description in html later. The `flow.steps` enables us to add/modify step ourselves. Here i add a new step `copy` and it only executes `concat`. The `js` and `css` steps are default.  
In `usemin` setting i add a `copy` function definition in `blockReplacements`. The function is quite simple. We need to set html and css folders too because usemin plugin needs to find files to modify in these folders.
</code>
  useminPrepare: {</p>

<pre><code>options: {
  dest: '&lt;%= gamenow.dist %&gt;',
  flow: {
    steps: {
      js: ['concat','uglifyjs'],
      css: ['concat','cssmin'],
      copy: ['concat']
    },
    post: {}
  }
},
html: '&lt;%= gamenow.app %&gt;/*.html'
</code></pre>

<p>  },</p>

<p>  usemin: {</p>

<pre><code>options: {
  assetsDirs: ['&lt;%= gamenow.dist %&gt;'],
  blockReplacements: {
    copy: function(block) {
      return '&lt;script src="' + block.dest + '"&gt;&lt;/script&gt;';
    }
  }
},
html: ['&lt;%= gamenow.dist %&gt;/*.html'],
</code></pre>

<p>  },
<code>
Let's take a look at sample.html. Use `&lt;!-- build:step path --&gt;` to wrap your css. Here the step is `css` and path is `css/all.css`. The usemin plugin will use `concat` to merge all css files to `css/all.css` and `cssmin` plugin to minify it.  
Use `&lt;!-- build:js path --&gt;` to optimize your JS. The `js` step will do `concat` and `ugilfy` in defult.
Use `&lt;!-- build:copy --&gt;` to only concat file without ugilfy. Because i want config file could be modified manually. Obfuscated file makes hard to modify.
</code> html sample.html
  <!-- build:css css/all.css -->
  <link rel="stylesheet" href="css/basics/normalize.css"  />
  <link rel="stylesheet" href="css/desktop/1.css"  />
  <link rel="stylesheet" href="css/desktop/2.css"  />
  <!-- endbuild --></p>

<p>  <!-- build:js js/build/vendor.js -->
  <script src="js/vendor/jquery-1.9.1.min.js"></script>
  <script src="js/vendor/jquery.scrollTo-1.4.3.1.js"></script>
  <script src="js/vendor/handlebars-v1.3.0.js"></script>
  <!-- endbuild --></p>

<p>  <!-- build:copy js/config.js -->
  <script src="js/settings/config.js"></script>
  <!-- endbuild -->
<code>
If you want to overwrite the default `cssmin` and `concat` settings you could just add the block in config. I overwrite the original concat process function. Because the css url path will be wrong if your source css and merged css are in different folder. See my comment inside function.
</code> javascript Gruntfile.js
  cssmin: {</p>

<pre><code>options: {
  noAdvanced: true
}
</code></pre>

<p>  },</p>

<p>  concat: {</p>

<pre><code>options: {
  separator: '\n',
  process: function(src, filepath) {
    var cssPatt = new RegExp('(\/.*\/).*\.css$');
    var file = cssPatt.exec(filepath);

    if (file) {
      // rewrite the url in css file.
      // url(../../img/bluebg.jpg) -&gt; url(../img/bluebg.jpg)
      // url(../../../img/bluebg2.jpg) -&gt; url(../img/bluebg.2jpg)

      var urlPatt = /url\((\.\.\/){1,}(.*)\)/g;
      return src.replace(urlPatt, function(match, p1, p2) {
        var replacedUrl = 'url(../' + p2 + ')';
        return replacedUrl;
      });
    }

    return src;
  }
}
</code></pre>

<p>  }
```</p>

<p>To prevent browser cache the js/css files need to change file name when the content are different. We use <code>rev</code> plugin to add <code>md5</code> in file name. Don't worry about the filename changed because <code>usemin</code> is smart enough to search files in <code>assetsDirs: ['&lt;%= gamenow.dist %&gt;']</code>.
``` javascript Gruntfile.js
  rev: {</p>

<pre><code>dist: {
  files: {
    src: [
      '&lt;%= gamenow.dist %&gt;/js/*.js',
      '&lt;%= gamenow.dist %&gt;/js/build/*.js',
      '&lt;%= gamenow.dist %&gt;/css/*.css',
    ]
  }
}
</code></pre>

<p>  },
<code>
In my module i also want to keep the originl .html file for debug. I add a task `debugHtml` to get it. I copy .html files to dist folder with `-dev` filename. Task `nonOptimizeFiles` is to copy the rest files.
</code>
  copy: {</p>

<pre><code>filesNeedRewrite: {
  files: [{
    expand: true,
    dot: true,
    cwd: '&lt;%= gamenow.app %&gt;',
    dest: '&lt;%= gamenow.dist %&gt;',
    src: ['*.html']
  }]
},
debugHtml: {
  files: [{
    expand: true,
    src: '&lt;%= gamenow.app %&gt;/*.html',
    dest: '&lt;%= gamenow.dist %&gt;/',
    rename: function(dest, src) {
      //rename *.html to *-dev.html
      var filename = path.basename(src, '.html');
      var extname = path.extname(src);
      return dest + filename + "-dev" + extname;
    }
  }]
},
nonOptimizeFiles: {
  files: [{
    expand: true,
    dot: true,
    cwd: '&lt;%= gamenow.app %&gt;',
    dest: '&lt;%= gamenow.dist %&gt;',
    src: [
      '*.{ico,png,xml,jsp,json}',
      '.htaccess',
      'WEB-INF/**',
      'img/**',

      //copy original js,css files for debug
      'js/*/**',
      'css/*/**'
    ]
  }]
} 
</code></pre>

<p>  }
<code>
The final optimized sample.html would be like
</code> html sample.html
  <link rel="stylesheet" href="css/46d81h87.all.css"  />
  <script src="js/build/xh64yr8d.vendor.js"></script>
  <script src="js/2sd4fgcv.config.js"></script>
```</p>

<p>The grunt build task sequence.
```
  grunt.registerTask('build', [</p>

<pre><code>'useminPrepare',
'concat',
'cssmin',
'uglify',
'copy:filesNeedRewrite',
'rev',
'usemin',
'copy:debugHtml',
'copy:nonOptimizeFiles'
</code></pre>

<p>  ]);
<code>
My package.json
</code> json package.json
{
  "name": "ugamenow",
  "version": "0.0.0",
  "devDependencies": {</p>

<pre><code>"grunt": "~0.4.1",
"load-grunt-tasks": "~0.2.0",
"time-grunt": "~0.2.0",

"grunt-contrib-clean": "~0.5.0",
"grunt-contrib-concat": "~0.3.0",
"grunt-contrib-cssmin": "~0.10.0",
"grunt-contrib-copy": "~0.5.0",
"grunt-contrib-uglify": "~0.2.0",
"grunt-rev": "~0.1.0",
"grunt-usemin": "~2.3.0"
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 preview]]></title>
    <link href="http://weichienhung.github.io/blog/2014/03/12/es6-preview/"/>
    <updated>2014-03-12T22:23:00+08:00</updated>
    <id>http://weichienhung.github.io/blog/2014/03/12/es6-preview</id>
    <content type="html"><![CDATA[<p>這篇文章用來記錄ES6的一些新功能。參考Lukehoban的<a href="https://github.com/lukehoban/es6features">版本</a>並加以中文化。
基本上所有的example codes我都有在<a href="http://www.es6fiddle.net/">ES6 fiddle</a>或用<a href="https://github.com/google/traceur-compiler">Traceur</a>執行過。</p>

<p>ES6包含這些新的功能:<br/>
- <a href="#let--const">let + const</a><br/>
- <a href="#enhanced-object-literals">enhanced object literals</a><br/>
- <a href="#arrows">arrows</a><br/>
- <a href="#classes">classes</a><br/>
- <a href="#template-strings">template strings</a><br/>
- <a href="#destructuring">destructuring</a><br/>
- <a href="#default--rest--spread">default + rest + spread</a><br/>
- <a href="#iterators--forof">iterators + for..of</a><br/>
- <a href="#generators">generators</a><br/>
- <a href="#comprehensions">comprehensions</a><br/>
- <a href="#unicode">unicode</a><br/>
- <a href="#modules">modules</a><br/>
- <a href="#module-loaders">module loaders</a><br/>
- <a href="#map--set--weakmap--weakset">map + set + weakmap + weakset</a><br/>
- <a href="#proxies">proxies</a><br/>
- <a href="#symbols">symbols</a><br/>
- <a href="#promises">promises</a><br/>
- <a href="#math--number--string--object-apis">math + number + string + object APIs</a><br/>
- <a href="#binary-and-octal-literals">binary and octal literals</a><br/>
- <a href="#reflect-api">reflect api</a><br/>
- <a href="#tail-calls">tail calls</a></p>

<h2>ECMAScript 6 Features</h2>

<h3><a name=let--const>Let + Const</a></h3>

<p><code>let</code>可以想成是新的<code>var</code>，建立的變數只會存活在Block scope裡。
<code>const</code>是用來建立常數。</p>

<p>``` javascript
function x() {
  let a = 2;
  a = a + 3;
  return a;
}</p>

<p>console.log(x()); //5
console.log(a); // undefined</p>

<p>let x = 44;
let x = 55; //應該要報錯，但目前模擬器實作都不會報錯
const b = "hello";
b = "abc"; //應該要報錯，但目前模擬器實作都不會報錯
```</p>

<h3><a name=enhanced-object-literals>Enhanced Object Literals</a></h3>

<p>增強的物件描述(Object Literal)支援在建構子設定prototype。可直接在定義的函數內呼叫父類別方法(super call)。</p>

<p>```
var foo = "i am foo";</p>

<p>var obj = {
  <strong>proto</strong>: [],</p>

<p>  // 定義方法
  getLength() {</p>

<pre><code>return this.length;
</code></pre>

<p>  },</p>

<p>  // 動態設定變數/方法名稱
  //foo:foo 的縮寫
  foo
};</p>

<p>obj.push("1");
console.log(obj.getLength()); //1
console.log(obj.prop_42); //"Should be 42"
console.log(obj.foo); //"i am foo"
```</p>

<h3><a name=arrows>Arrows</a></h3>

<p>箭號'=>'是一種定義函數的縮寫方式。
同時支援函數表達式(function expression)跟函數聲明(function statement)。
但跟傳統函數有點不一樣的是在箭號定義函數裡面的this是跟呼叫它的程式碼擁有一樣的lexical scope。</p>

<p>```
let square = x => x * x;
let add = (a, b) => a + b;
let pi = () => 3.1415;</p>

<p>console.log(square(5)); //25
console.log(add(3, 4)); //7
console.log(pi()); //3.1415</p>

<p>// Lexical this
var bob = {
  <em>name: "Bob",
  </em>friends: ['Ken'],
  printFriends() {</p>

<pre><code>this._friends.forEach(f =&gt;
  console.log(this._name + " knows " + f)
);
</code></pre>

<p>  }
}
bob.printFriends(); //Bob knows Ken
```</p>

<h3><a name=classes>Classes</a></h3>

<p>ES6類別提供一種簡單宣告方式讓class pattern更容易使用。
類別支援繼承(inheritance)，父類別呼叫(super calls)，建構子(constructor)，個體方法(instance method)和類別方法(class method)。</p>

<p>```
class Polygon {
  constructor(height, width) { //class constructor</p>

<pre><code>this.name = 'Polygon';
this.height = height;
this.width = width;
</code></pre>

<p>  }</p>

<p>  static doIt() {  //class method</p>

<pre><code>console.log('Do it now');
</code></pre>

<p>  }
}</p>

<p>class Square extends Polygon {
  constructor(length) {</p>

<pre><code>super(length, length); //call the parent method with super
this.name = 'Square';
</code></pre>

<p>  }</p>

<p>  get area() { //calculated attribute getter</p>

<pre><code>return this.height * this.width;
</code></pre>

<p>  }
}</p>

<p>let s = new Square(5);
console.log(s.area); //25
Square.doIt(); //"Do it now"
```</p>

<h3><a name=template-strings>Template Strings</a></h3>

<p>Template String提供許多方便方法建立字串。
還可以使用函式來預先處理Template String。被稱為Tagged Template String。可以避免被塞入非預期中的字串。</p>

<p><code>``
var myString =</code>In JavaScript '\n' is a line-feed.`;</p>

<p>// Multiline strings
var myString2 = <code>In JavaScript this is
 not legal.</code>;</p>

<p>var name = "Bob", time = "today";
var myString3 = <code>Hello ${name}, how are you ${time}?</code></p>

<p>console.log(myString); //"In JavaScript ' ' is a line-feed."
console.log(myString2); //"In JavaScript this is not legal."
console.log(myString3); //"Hello Bob, how are you today?"</p>

<p>function tag(strings, ...values) {
  if (!(strings[0] === 'a' &amp;&amp; strings[1] === 'b')) {</p>

<pre><code>return 'bad';
</code></pre>

<p>  }
  return 'good';
}
console.log(tag <code>a${ 123 }b</code>);  // "good"
console.log(tag <code>c${ 123 }d</code>);  // "bad"
```</p>

<h3><a name=destructuring>Destructuring</a></h3>

<p>Destructuring assignment允許使用陣列或物件pattern來自動給予值。
Destructuring是錯誤安全(fail-soft)的。當配對不上時會給予undefined。</p>

<p>```
let [one, two, three] = [1, ,3];
let {four, five} = {four:4, five:  5};
console.log(two === undefined); //true
console.log(one, two, three, four, five); // 1 3 4 5</p>

<p>function today() { return { d: 11, m: 3, y: 2014 }; }
var { m: month, y: year } = today();
console.log(month); //3
console.log(year); //2014</p>

<p>books = [];
books.push({ title:"hello", author:"samuel" });
books.push({ title:"hello2", author:"samuel2" });
books.forEach(function ({ title: t, author: a }) {
  console.log(t, a);
  // hello samuel
  // hello2 samuel2
})</p>

<p>```</p>

<h3><a name=default--rest--spread>Default + Rest + Spread</a></h3>

<p>函數參數可設定預設值(Default)</p>

<p><code>
function f(x, y=12) {
  // y值會是12 當呼叫者沒有傳入值或傳入值為undefined
  return x + y;
}
console.log(f(3)); //15
console.log(f(3, undefined)); //15
console.log(f(3, null)); //3
console.log(f(3, 4)); //7
</code>
不定長度函數參數(Rest Parameter)，函數傳入值當做陣列處理</p>

<p><code>
function f(x, ...y) {
  // y 是一個陣列
  return x * y.length;
}
console.log(f(3, "hello", true)); //6
console.log(f(3, "hello", true, 444)); //9
</code></p>

<p>Spread Operator可使用陣列當做函數參數，陣列內的值會被當做相對應的參數值
```
function f(x, y, z) {
  return x + y + z;
}
console.log(f(...[1,2,3])); //6
console.log(f(...[1,2,3,4,5])); //6</p>

<p>var x = [1, 2];
var y = [3, 4];
x.push(...y);<br/>
console.log(x); //1,2,3,4
```</p>

<h3><a name=iterators--forof>Iterators + For..Of</a></h3>

<p>Iterator Object讓使用者可以客製化iteration行為，就像Java的Iteratable。
```
//For..Of
let arr = [1, 2, 3, 4, 5];
let sum = 0;</p>

<p>for (let v of arr) {
  sum += v;
}</p>

<p>console.log('1 + 2 + 3 + 4 + 5 =', sum); // 1 + 2 + 3 + 4 + 5 = 15</p>

<p>//Basic Iterator
// fibonacci整個object就是iterator
let fibonacci = {
  <a href="">Symbol.iterator</a> {</p>

<pre><code>let pre = 0, cur = 1;
return {
  next() {
    [pre, cur] = [cur, pre + cur]; //每次循徊把pre值設成cur，cur值則為cur+pre
    return { done: pre &gt; 100, value: pre } //當pre值大於100時終止
  }
}
</code></pre>

<p>  }
}</p>

<p>for (var n of fibonacci) {
  console.log(n); // 1 1 2 3 5 8 13 21 34 55 89
}</p>

<p>// Iteration相關的介面
interface IteratorResult {
  done: boolean;
  value: any;
}
interface Iterator {
  next(): IteratorResult;
}
interface Iterable {
  <a href="">Symbol.iterator</a>: Iterator
}</p>

<p>```</p>

<h3><a name=generators>Generators</a></h3>

<p>Generator使用<code>function*</code>來宣告函數並且返回一個Generator實例。
Generator實例是一種Iterator。可以透過<code>yield</code>與<code>next</code>可以一步一步執行函數內容。</p>

<p>```
function* range(start, end, step) {
  while (start &lt; end) {</p>

<pre><code>yield start;
start += step;
</code></pre>

<p>  }
}</p>

<p>for (let i of range(0, 10, 2)) {
  console.log(i); // 0 2 4 6 8
}</p>

<p>//Fibonacci數列實作by Generator
var fibonacci = function*() {
  var pre = 0, cur = 1;
  while (true) {</p>

<pre><code>yield cur;
var tmp = cur;
cur += pre;
pre = tmp;
</code></pre>

<p>  }
}</p>

<p>f = fibonacci();
for (var n of f) {
  if (n > 100)</p>

<pre><code>break;
</code></pre>

<p>  console.log(n); // 1 1 2 3 5 8 13 21 34 55 89
}</p>

<p>//你也可以自己使用next一步一步取值
//可以用done這個boolean值來判斷是否已經沒有next
f = fibonacci();
var obj;
while (!(obj = f.next()).done) {
  if (obj.value > 100) {</p>

<pre><code>break;
</code></pre>

<p>  }
  console.log(obj.value);  // 1 1 2 3 5 8 13 21 34 55 89
}</p>

<p>// Generator的介面
interface Generator extends Iterator {
  next(value?: any): IteratorResult;
  throw(exception: any);
}</p>

<p>```</p>

<h3><a name=comprehensions>Comprehensions</a></h3>

<p>Array Comprehension和Generator Comprehension提供簡單方式來處理數列</p>

<p>```
//Array Comprehension
let arr = [1, 2, 3, 4, 5];
let squared = [for (x of arr) x * x];</p>

<p>console.log(squared); //1,4,9,16,25</p>

<p>//Generator Comprehension
let squared2 = (for (x of arr) x * x);</p>

<p>for (let z of squared2) {
  console.log(z); //1 4 9 16 25
}</p>

<p>```</p>

<h3><a name=unicode>Unicode</a></h3>

<p>完整21bit的Unicode支援</p>

<p>```
// same as ES5.1
console.log("𠮷".length == 2); //true</p>

<p>// new RegExp behaviour, opt-in ‘u’
//console.log("𠮷".match(/./u)[0].length == 2); //在ES6模擬器上無法使用</p>

<p>// new form
console.log("\uD842\uDFB7" == "𠮷"); //true
//console.log("\u{20BB7}" == "𠮷"); //在ES6模擬器上無法使用</p>

<p>// new String ops
console.log("𠮷".codePointAt(0) == 0x20BB7); //true</p>

<p>//在ES6模擬器上無法使用
// for-of iterates code points
//for(var c of "𠮷") {
//  console.log(c);
//}</p>

<p>```</p>

<h3><a name=modules>Modules</a></h3>

<p>像AMD,CommonJS一樣可以自行定義module以及彼此之間的相依性。</p>

<p><code>
// lib/math.js
export function sum(x, y) {
  return x + y;
}
export var pi = 3.141593;
var msg2 = "Ya";
export { msg2 as message};  
</code>
使用<code>module</code>語法載入math.js
<code>
// app.js
module math from "lib/math";
console.log("2π = " + math.sum(math.pi, math.pi)); //2π = 6.283186
console.log(math.msg2); //undefined
console.log(math.message); //Ya
</code>
使用<code>import</code>語法來載入sum函數和pi變數
<code>
// otherApp.js
import {sum, pi} from "lib/math";
console.log("2π = " + sum(pi, pi)); //2π = 6.283186
console.log(message); //undefined
</code></p>

<h3><a name=module-loaders>Module Loaders</a></h3>

<p>Module Loader提供動態載入(Dynamic loading)，命名空間(Namespace)，狀態獨立(State isolation)等功能
```
//更改預設js目錄
System.baseURL = '/lib/';</p>

<p>//動態載入math.js
System.import('math').then(function(m) {
  //m 是math的namespace
  console.log("2π = " + m.sum(m.pi, m.pi)); //2π = 6.283186
});</p>

<p>//理論上可以用Loader來執行程式碼在某一個context底下
//但模擬器找不到Loader..
// Create execution sandboxes – new Loaders
var loader = new Loader({
  global: fixup(window) // replace ‘console.log’
});
loader.eval("console.log('hello world!');");
```</p>

<h3><a name=map--set--weakmap--weakset>Map+Set+Weakmap+Weakset</a></h3>

<p>新的資料結構，由於目前模擬器都還沒有實作所以沒有親自試過。不過我相信這部份上手很快不難。</p>

<p>```
// Sets
var s = new Set();
s.add("hello").add("goodbye").add("hello");
s.size === 2;
s.has("hello") === true;</p>

<p>// Maps
var m = new Map();
m.set("hello", 42);
m.set(s, 34);
m.get(s) == 34;</p>

<p>// Weak Maps
var wm = new WeakMap();
wm.set(s, { extra: 42 });
wm.size === undefined</p>

<p>// Weak Sets
var ws = new WeakSet();
ws.add({ data: 42 });
// Because the added object has no other references, it will not be held in the set
```</p>

<h3><a name=proxies>Proxies</a></h3>

<p>Proxy故名思義就是讓對某一個物件(host object)的所有行為透過代理物件(proxy object)。
方便用來logging或效能分析(profiling)。目前模擬器還沒實作。
```
// Proxying a normal object
var target = {};
var handler = {
  get: function (receiver, name) {</p>

<pre><code>return `Hello, ${name}!`;
</code></pre>

<p>  }
};</p>

<p>var p = new Proxy(target, handler);
p.world === 'Hello, world!';
<code>
</code>
// Proxying a function object
var target = function () { return 'I am the target'; };
var handler = {
  apply: function (receiver, ...args) {</p>

<pre><code>return 'I am the proxy';
</code></pre>

<p>  }
};</p>

<p>var p = new Proxy(target, handler);
p() === 'I am the proxy';
```</p>

<h3><a name=symbols>Symbols</a></h3>

<p>Symbol是一種新的primitive type。Symbol可以用來當做property的key值而且是唯一的。</p>

<p>```
var key = Symbol("key");</p>

<p>function MyClass(privateData) {
  this[key] = privateData;
}</p>

<p>MyClass.prototype = {
  say: function() {</p>

<pre><code>console.log(this[key]);
</code></pre>

<p>  }
};</p>

<p>var c = new MyClass("hello")
console.log(c["key"]); //undefined 因為Symbol並不是String
console.log(c[key]); //hello
console.log(c.say()); //hello
```</p>

<h3><a name=promises>Promises</a></h3>

<p>Promise就不用再多提，目前已經有很多現成的ES5 library有實作Promise pattern了。
像<a href="https://github.com/tildeio/rsvp.js">RSVP.js</a>和<a href="https://github.com/kriskowal/q">Q</a>。</p>

<p>```
var promise = new Promise(function(resolve, reject) {
  // do a thing, possibly async, then…</p>

<p>  if (/<em> everything turned out fine </em>/) {</p>

<pre><code>resolve("Stuff worked!");
</code></pre>

<p>  }
  else {</p>

<pre><code>reject(Error("It broke"));
</code></pre>

<p>  }
});</p>

<p>promise.then(function(result) {
  console.log(result); // "Stuff worked!"
}, function(err) {
  console.log(err); // Error: "It broke"
});
```</p>

<h3><a name=math--number--string--object-apis>Math+Number+String+Object APIs</a></h3>

<p>ES6增加了許多好用的函數。底下範例在目前模擬器上尚無法完全支援。</p>

<p>```
Number.EPSILON
Number.isInteger(Infinity) // false
Number.isNaN("NaN") // false</p>

<p>Math.acosh(3) // 1.762747174039086
Math.hypot(3, 4) // 5
Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2</p>

<p>"abcde".contains("cd") // true
"abc".repeat(3) // "abcabcabc"</p>

<p>Array.from(document.querySelectorAll('*')) // Returns a real Array
Array.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior
[0, 0, 0].fill(7, 1) // [0,7,7]
[1,2,3].findIndex(x => x == 2) // 1
["a", "b", "c"].entries() // iterator [0, "a"], [1,"b"], [2,"c"]
["a", "b", "c"].keys() // iterator 0, 1, 2
["a", "b", "c"].values() // iterator "a", "b", "c"</p>

<p>//Object copying
Object.assign(Point, { origin: new Point(0,0) })
```</p>

<h3><a name=binary-and-octal-literals>Binary and Octal Literals</a></h3>

<p>新的二進位(b)和八進位(o)表示式</p>

<p><code>
console.log(0b111110111 === 503); // true
console.log(0o767 === 503); // true
</code></p>

<h3><a name=reflect-api>Reflect API</a></h3>

<p>參考<a href="http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api">ECMAScript wiki</a>。</p>

<h3><a name=tail-calls>Tail Calls</a></h3>

<p>Tail Call最佳化讓遞迴程式call stack不會無限增加導致記憶體用完。</p>

<p>```
function factorial(n, acc = 1) {</p>

<pre><code>'use strict';
if (n &lt;= 1) return acc;
return factorial(n - 1, n * acc);
</code></pre>

<p>}</p>

<p>// 在目前的browser幾乎都會stack overflow
// 未來ES6上面是安全的
factorial(100000);
```</p>
]]></content>
  </entry>
  
</feed>
