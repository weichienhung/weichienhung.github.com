<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | Practice makes perfect]]></title>
  <link href="http://weichienhung.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://weichienhung.github.io/"/>
  <updated>2014-03-17T23:03:14+08:00</updated>
  <id>http://weichienhung.github.io/</id>
  <author>
    <name><![CDATA[Weichien Hung]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[nginx configuration]]></title>
    <link href="http://weichienhung.github.io/blog/2014/01/25/nginx-configuration/"/>
    <updated>2014-01-25T10:04:00+08:00</updated>
    <id>http://weichienhung.github.io/blog/2014/01/25/nginx-configuration</id>
    <content type="html"><![CDATA[<p>As a web developer, nginx is often used in deployment architecture.
Write down the useful nginx configuration examples here.</p>

<p>Intall nginx is very easy and not describe here. Configuration good reference <a href="https://calomel.org/nginx.html">here</a></p>

<p>底下的設定值是用最基本的nginx install, 沒有額外的module</p>

<h3>Basic configuration</h3>

<p>``` sh /etc/nginx/nginx.conf</p>

<h1>最基本的設定,不詳述</h1>

<p>user  nginx;
worker_processes  1;
pid        /var/run/nginx.pid;</p>

<p>events {
  worker_connections  1024;
}</p>

<p>http {
  # 載入支援的mime type
  include       /etc/nginx/mime.types;</p>

<p>  # 當有不認識的mime type時就用octet-stream當一般binary檔案處理
  default_type  application/octet-stream;</p>

<p>  # 定義自己的log format
  log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</p>

<pre><code>                '$status $body_bytes_sent "$http_referer" '
                '"$http_user_agent" "$http_x_forwarded_for"';
</code></pre>

<p>  # access log存放位置並且使用 main 這個log format,也就是上述定義的格式
  # buffer=8k 表示不會一直寫log到disk,等到buffer滿了才寫,避免I/O過重
  access_log  /var/log/nginx/access.log main buffer=8k;</p>

<p>  ## Size Limits
  # 當request body超過這個body size時會被先寫進暫存檔處理
  client_body_buffer_size   8k;</p>

<p>  # 限制http header的大小
  client_header_buffer_size 1k;</p>

<p>  # 限制request body大小，超過server會回傳413(Request Entity Too Large)
  client_max_body_size      1m;</p>

<p>  ## Timeouts, do not keep connections open longer then necessary to reduce
  # 讀取request body timeout時間,超過時間會回傳408(Request time out)
  client_body_timeout     4s;</p>

<p>  # 讀取request header timeout時間(e.g GET HTTP/1.1),超過時間回傳408(Request time out)
  client_header_timeout   2s;</p>

<p>  # HTTP 1.1 keepalive的timeout時間, 各家browser各有不同時間.
  keepalive_timeout       65s;</p>

<p>  # 送資料給client的timeout時間(指得是兩次資料讀取時間), 降低這個值可以避免Slowloris DoS attack
  send_timeout            5s;</p>

<p>  ## General Options
  # 設定值 >=1 的話讓NGINX支持下載部份檔。 如果你的server有要讓人下載大檔續傳的話..
  max_ranges 0;</p>

<p>  # keepalive的連線最大數量
  keepalive_requests        5;</p>

<p>  # Browder cache 失效時間, 負值的話表示不要有任何cache.
  expires 1d;</p>

<p>  # Request limits
  # 限制一個IP在1秒內只處理5個requests
  # myzone是自行定義的名稱,用來存放IP, 2m表示最大不超過2M記憶體
  limit_req_zone  $binary_remote_addr  zone=myzone:2m  rate=5r/s;</p>

<p>  # 載入其它設定檔
  include /etc/nginx/conf.d/*.conf;</p>

<p>}
```</p>

<h3>How to reverse proxy?</h3>

<!-- more -->


<p>Separate the config from nginx.conf is good practice. I move server defination into <code>default.conf</code>
``` sh /etc/nginx/conf.d/default.conf</p>

<h1>定義在後端的servers</h1>

<p>upstream backend_web_servers {
  server 192.168.0.102:3000 max_fails=250 fail_timeout=180s;
  server 192.168.0.103:3000 max_fails=250 fail_timeout=180s;</p>

<p>  # 設了backup後只有當上面102,103 server都掛點時才會導request到底下100
  server 192.168.0.100 backup;
}</p>

<p>server {
  # listening on 80 port. 額外設定socket receive和send buffer size
  listen 80 rcvbuf=8k sndbuf=8k;</p>

<p>  # server名稱
  server_name www.myserver.io</p>

<p>  ＃ 文件根目錄<br/>
  root /usr/share/nginx/html;</p>

<p>  # 限制一個IP不能超過10個open connections. nodelay會讓超過限制的connection直接回傳503不等待
  limit_req zone=myzone burst=10 nodelay;</p>

<p>  # location 怎麼用可以參考http://cssor.com/nginx-location-configuration.html
  location / {</p>

<pre><code>try_files $uri @backend_web_servers;
</code></pre>

<p>  }</p>

<p>  location @backend_web_servers {</p>

<pre><code># 允許proxies server cache網頁，看個人需求。如果你的網頁有太多個人資訊就不建議public
add_header  Cache-Control "public";

# 不允許網頁內容被放進iframe
add_header  X-Frame-Options "DENY";

# header設定. 將real ip傳進backend servers
proxy_set_header   Host             $host;
proxy_set_header   X-Real-IP        $remote_addr;
proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;

# 將request proxy到後端server
proxy_pass http://backend_web_servers;
</code></pre>

<p>  }</p>

<p>}
```</p>

<h3>Redirect domain name.</h3>

<p>For instance: redirect <code>http://myserver.io</code> to <code>http://www.myserver.io</code>.
The official document suggest us using <code>return</code> not <code>rewrite</code>.
``` sh /etc/nginx/conf.d/redirect_server.conf
server {
  listen 80;
  server_name myserver.io;
  return 301 $scheme://www.myserver.io$request_uri;
}</p>

<p>```</p>

<h3>Enable/Disable Maintenance mode</h3>

<p>If the maintenance.html exists, it shows maintenance page first.
And disable the cache(set <code>expires -1</code>) to prevent browser cache maintenance.html.
``` sh /etc/nginx/conf.d/default.conf
location / {
  try_files /maintenance.html $uri @backend_web_servers;
}</p>

<p>location /maintenance.html {
  expires -1; # prevent maintenance.html cached
}
```</p>

<h3>Serve static resources for RAILS</h3>

<p>All requests to assets folder like <code>http://127.0.0.1/assets/applicatoin-xxxxx.js</code> will be served by Nginx.
<code>sh /etc/nginx/conf.d/default.conf
location ^~ /assets/ {
  root /home/rails/myrail/public/;
}
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[memcached study]]></title>
    <link href="http://weichienhung.github.io/blog/2013/08/07/memcached-study/"/>
    <updated>2013-08-07T21:27:00+08:00</updated>
    <id>http://weichienhung.github.io/blog/2013/08/07/memcached-study</id>
    <content type="html"><![CDATA[<p>I studied the memcached since yesterday. It's a good cache implementation used by Twitter,Facebook..etc.
Because the official site doesn't provide the rpm for download and i can't get the latest version from yum.
I learn how to build it from source and also try the <a href="http://repcached.lab.klab.org/">repached</a>(for memcached replication but not official)</p>

<!-- more -->


<h2>how to install memcached from source</h2>

<p>You can refer to <a href="https://code.google.com/p/memcached/wiki/NewInstallFromSource">link</a>(i didn't find this post until i solve the installation XD)</p>

<h3>install libevent dependency</h3>

<p>I try download the libevent source from website and build it. But i found <code>yum</code> is the easiest. Don't worry if your libevent version is 1.4.x not 2.0.x.
memcached-1.4.15 can be build with libevent-1.4.x
<code>sh
yum install libevent-devel
</code></p>

<h3>download the memcached-1.x.x.tar from <a href="http://memcached.org/">memcached.org</a> and untar</h3>

<p><code>
tar zxvf memcached-1.x.x.tar
</code></p>

<h3>make it</h3>

<p>```sh
./configure --prefix=/usr/local/memcached-1.4.x/</p>

<p>make</p>

<p>make install
<code>``
you may fail in</code>configure<code>and show no libevent dependency. you should add</code>--with-libevent=/usr/local/libevent/`(your libevent library folder) in configure</p>

<h2>start memcached</h2>

<p>```
cd /usr/local/memcached-1.4.x/bin/</p>

<p>./memcached -u nobody -p 11211 -P /usr/local/memcached-1.4.x/bin/mem.pid -d -v
```</p>

<h2>stop memcached</h2>

<p>find the process id from /usr/local/memcached-1.4.x/bin/mem.pid and kill it</p>

<h2>how to make memcached cluster</h2>

<p>Each memcached node is configured independently in the cluster. They don't communicate or exchange data. It's the client's job to decide which
server  from the cluster. Clients may use the consistent-hash to choose a memcached node and write/read data.<br/>
Memcached make your application performance better but your application have to work correctly even the memcached servers crash.
Memcached is not the storage solution.</p>

<h2>install memcached with repcache</h2>

<p>I upload the related repache patch and memcached-1.4.4 source to Dropbox. You can download from it.
<code>
wget --no-check-certificate https://dl.dropboxusercontent.com/u/60216960/memcached-1.4.4.zip
</code></p>

<h3>patch source before configure</h3>

<p><code>
patch -p1 -i repcached-2.2-1.4.4.patch
</code></p>

<h3>make it</h3>

<p>```
./configure --enable-replication --prefix=/usr/local/memcached-1.4.4-rep/</p>

<p>make</p>

<p>make install
```</p>

<h2>start memcached with repcache</h2>

<p>For example, we have two servers: server 1(192.168.0.103) and server 2(192.168.0.101)<br/>
In server 1
<code>
./memcached -u nobody -v -p 11211 -X 11212
</code>
In server 2
<code>
./memcached -u nobody -v -p 11211 -x 192.168.0.103 -X 11212
</code></p>

<h3>test the replication</h3>

<p>add key in server 1
<code>
telnet 192.168.0.103 11211
add hello 0 0 2
99
</code>
read in server 2
<code>
telnet 192.168.0.101 11211
get hello
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[shell script on linux ]]></title>
    <link href="http://weichienhung.github.io/blog/2013/07/10/linux-shellscript/"/>
    <updated>2013-07-10T22:15:00+08:00</updated>
    <id>http://weichienhung.github.io/blog/2013/07/10/linux-shellscript</id>
    <content type="html"><![CDATA[<p>前陣子用linux shell script寫了module自動deploy機制。紀錄一下這之中遇到的問題及常用的指令。<br/>
簡單的自動deploy不外乎就是將檔案傳送至遠端機器然後進行安裝動作，修改設定檔。</p>

<ul>
<li><h3>login to remote server</h3></li>
</ul>


<!-- more -->


<p>由於原生shell script裡面無法自動輸入帳密進行登錄動作，基本上常用的方法有兩種。<br/>
第一種方法就是建立ssh public key然後放在遠端機器上，這樣你ssh時就不需要再輸入密碼。
第二種方法是安裝其它套件協助自動輸入密碼。在這裡我介紹的是使用<a href="http://sourceforge.net/projects/sshpass/">sshpass</a>。
安裝完後要記得自己先手動登入一次遠端機器，不然它不會作用。接下來你要登入遠端機器的指令就如下
<code>sh
sshpass -p {your password} ssh root@{remote ip} "echo 'hello world'"
</code>
這樣就可以登入遠端機器並輸出一個hello world。</p>

<p>另外你也可以用scp來拷貝資料過去
<code>
sshpass -p {your password} scp data.zip root@{remote ip}:/home/root/
</code>
這樣就可以把data.zip丟到遠端/home/root/目錄</p>

<ul>
<li><h3>execute command on remote server</h3>

簡單地方法就是在sshpass之後帶入command
<code>sh
sshpass -p {your password} ssh root@{remote ip} "mkdir myFolder;rm myFile.txt"
</code>
這樣就可以在登入後執行mkdir及rm兩個指令。
另一種方法就是把你要執行的指令寫成一個shell script，然後scp過去後執行。例如我把這兩行指令寫在myScript.sh裡
``` sh

<h1>!/bin/bash</h1>

<p>mkdir myFolder
rm myFile.txt
<code>
然後執行底下指令
</code>
sshpass -p {your password} scp myScript.sh root@{remote ip}:/home/root/
sshpass -p {your password} ssh root@{remote ip} "/home/root/myScript.sh"
```</p></li>
<li><h3>retrieve the specified string from a line</h3>

<p>例如我有一個my.xml檔裡面紀錄了最新的版號如下
<code>xml
&lt;myxml&gt;
  &lt;release&gt;1.0.22&lt;/release&gt;
&lt;/myxml&gt;
</code>
用底下的指令來取出版號
<code>sh
latest=$(cat my.xml | sed -n 's/.*&lt;release&gt;\(.*\)&lt;\/release&gt;/\1/p')
</code>
由於(, ), /是特殊字元,所以在re裡前面都要加上\<br/>
後面的\1表示要取result的第一個group。<br/>
整個用$()包覆是因為要把執行結果放進latest這個變數。</p></li>
<li><h3>replace string in a config file</h3>

<p>使用sed指令加上regular expression
<code>sh
sed -i 's/.*MyTest.*/YourTest/' config.txt
</code>
這樣就可以把config.txt裡面所有字串裡中間有MyTest替換成YourTest</p></li>
<li><h3>insert a new line in a config file</h3>

<p>使用sed指令加上regular expression
<code>sh
sed -i 's/.*MyTest.*/&amp;\nYourTest/g' config.txt
</code>
這樣就可以在config.txt裡面插入新的一行YourTest在每一行符合中間有MyTest的字串。</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
